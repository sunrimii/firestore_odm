import 'package:cloud_firestore/cloud_firestore.dart' as firestore;
import 'package:firestore_odm/src/RecordHelper.dart';
import 'package:firestore_odm/src/filter_builder.dart';
import 'package:firestore_odm/src/firestore_collection.dart';
import 'package:firestore_odm/src/interfaces/gettable.dart';
import 'package:firestore_odm/src/interfaces/streamable.dart';
import 'package:firestore_odm/src/model_converter.dart';
import 'package:firestore_odm/src/schema.dart';
import 'package:firestore_odm/src/services/update_operations_service.dart';
import 'package:firestore_odm/src/utils.dart';

class OrderByFieldSelector<T> {
  final String prefix;
  final List<OrderByFieldInfo> _fields;

  // Value extraction mode - extracts actual values from object
  final bool _isExtractionMode;
  final Map<String, dynamic>? _sourceObject;
  final List<dynamic> _extractedValues = [];

  /// Create a field selector with optional prefix for nested fields
  /// If parentFields is provided, nested selectors will share the same field collection
  OrderByFieldSelector({
    this.prefix = '',
    List<OrderByFieldInfo>? parentFields,
    bool isExtractionMode = false,
    Map<String, dynamic>? sourceObject,
  }) : _fields = parentFields ?? <OrderByFieldInfo>[],
       _isExtractionMode = isExtractionMode,
       _sourceObject = sourceObject;

  /// Get the collected orderBy fields
  List<OrderByFieldInfo> get fields => _fields;

  /// Get extracted values (only available in extraction mode)
  List<dynamic> get extractedValues => _extractedValues;

  /// Public getters for extraction mode state (needed by generated extensions)
  bool get isExtractionMode => _isExtractionMode;
  Map<String, dynamic>? get sourceObject => _sourceObject;

  /// Add a field to the orderBy configuration
  /// Returns the field type to enable tuple type inference OR extracted value
  R addField<R>(dynamic fieldPath, bool descending, Type fieldType) {
    String fullPath;
    if (fieldPath is String) {
      fullPath = prefix.isEmpty ? fieldPath : '$prefix$fieldPath';
    } else {
      // Handle FieldPath objects (e.g., FieldPath.documentId)
      fullPath = fieldPath.toString();
    }

    if (_isExtractionMode) {
      // Extract actual value from source object
      if (fieldPath == firestore.FieldPath.documentId) {
        // For document ID, extract from the object's id field
        final value =
            _sourceObject!['id'] ??
            _sourceObject['_id'] ??
            _sourceObject.keys.first;
        _extractedValues.add(value);
        return value as R;
      } else {
        final value = _extractNestedValue(_sourceObject!, fullPath);
        _extractedValues.add(value);
        return value as R;
      }
    } else {
      // Normal orderBy mode - collect field info and return type placeholder
      if (fieldPath == firestore.FieldPath.documentId) {
        // For document ID, store the actual FieldPath.documentId object
        _fields.add(
          OrderByFieldInfo(
            firestore.FieldPath.documentId,
            descending,
            fieldType,
          ),
        );
      } else {
        _fields.add(OrderByFieldInfo(fullPath, descending, fieldType));
      }
      // Return default value of the type for type inference
      switch (fieldType) {
        case == int:
          return 0 as R;
        case == double:
          return 0.0 as R;
        case == String:
          return '' as R;
        case == bool:
          return false as R;
        case == DateTime:
          return DateTime.now() as R;
        default:
          // For other types, return null cast to R
          return null as R;
      }
    }
  }

  /// Extract nested value from object map using dot notation
  static dynamic _extractNestedValue(
    Map<String, dynamic> map,
    String fieldPath,
  ) {
    final parts = fieldPath.split('.');
    dynamic current = map;

    for (final part in parts) {
      if (current is Map<String, dynamic> && current.containsKey(part)) {
        current = current[part];
      } else {
        return null;
      }
    }

    return current;
  }

  // Field accessor methods are code-generated by OrderByGenerator
  // Each method returns the field type (int, String, etc.) to build the tuple type
  // Example generated methods:
  // int age([bool descending = false]) => addField('age', descending, int);
  // String name([bool descending = false]) => addField('name', descending, String);
}

/// Information about an orderBy field for pagination
class OrderByFieldInfo {
  final dynamic fieldPath; // Can be String or FieldPath
  final bool descending;
  final Type fieldType;

  const OrderByFieldInfo(this.fieldPath, this.descending, this.fieldType);

  @override
  String toString() =>
      'OrderByFieldInfo($fieldPath, desc: $descending, type: $fieldType)';
}

/// Container for orderBy configuration used in pagination
class OrderByConfiguration {
  final List<OrderByFieldInfo> fields;

  const OrderByConfiguration(this.fields);

  /// Check if this configuration is empty
  bool get isEmpty => fields.isEmpty;

  /// Get field types as a tuple-like representation
  List<Type> get fieldTypes => fields.map((f) => f.fieldType).toList();

  @override
  String toString() => 'OrderByConfiguration(${fields.join(', ')})';
}

class Query<
  S extends FirestoreSchema,
  T,
  Ordered extends Record?,
  Limited extends int?
>
    implements Gettable<List<T>>, Streamable<List<T>> {
  final FirestoreCollection<S, T> collection;

  /// The underlying Firestore query
  final firestore.Query<Map<String, dynamic>> query;

  final OrderByConfiguration? _orderByConfig;
  final Ordered Function(OrderByFieldSelector<T>)? _orderByBuilder;

  const Query(
    this.collection,
    this.query, [
    this._orderByConfig,
    this._orderByBuilder,
  ]);

  @override
  Future<List<T>> get() {
    return query.get().then((snapshot) {
      return processQuerySnapshot<T>(
        snapshot,
        collection.converter.fromJson,
        collection.documentIdField,
      );
    });
  }

  @override
  Stream<List<T>> get stream =>
      lazyBroadcast(() => query.snapshots()).map((snapshot) {
        return processQuerySnapshot<T>(
          snapshot,
          collection.converter.fromJson,
          collection.documentIdField,
        );
      });
}

extension GettableExt<
  S extends FirestoreSchema,
  T,
  R extends Map<String, dynamic>
>
    on Query<S, T, dynamic, dynamic> {
  /// Gets the first document matching the query
  Future<List<T>> get() {
    return query.get().then((snapshot) {
      return snapshot.docs.isNotEmpty
          ? snapshot.docs.map((doc) {
              return fromFirestoreData(
                collection.converter.fromJson,
                doc.data(),
                collection.documentIdField,
                doc.id,
              );
            }).toList()
          : [];
    });
  }
}

extension FilterableExt<
  S extends FirestoreSchema,
  T,
  R,
  O extends Record?,
  L extends int?
>
    on Query<S, T, O, L> {
  /// Adds a filter to the query
  Query<S, T, O, L> where(
    FirestoreFilter<T> Function(RootFilterBuilder<T> builder) filterBuilder,
  ) {
    final builder = RootFilterBuilder<T>();
    final builtFilter = filterBuilder(builder);
    final newQuery = applyFilterToQuery(query, builtFilter);
    
    // Handle different types of query objects
    if (this is FirestoreCollection<S, T>) {
      return Query<S, T, O, L>(collection, newQuery, null, null);
    } else {
      return Query<S, T, O, L>(collection, newQuery, _orderByConfig, _orderByBuilder);
    }
  }
}

extension OrderableExt<S extends FirestoreSchema, T, L extends int?>
    on Query<S, T, Null, L> {
  /// Orders the query by the specified fields
  Query<S, T, O, L> orderBy<O extends Record>(
    O Function(OrderByFieldSelector<T> selector) orderBuilder,
  ) {
    final selector = OrderByFieldSelector<T>();
    
    // Call the order builder to populate the selector
    orderBuilder(selector);

    // Build the actual Firestore query from the collected fields
    firestore.Query<Map<String, dynamic>> newQuery = query;
    for (final field in selector.fields) {
      newQuery = newQuery.orderBy(
        field.fieldPath,
        descending: field.descending,
      );
    }

    // Create configuration from the collected fields - convert to pagination format
    final pgFields = selector.fields
        .map((f) => OrderByFieldInfo(f.fieldPath, f.descending, f.fieldType))
        .toList();
    final config = OrderByConfiguration(pgFields);

    return Query<S, T, O, L>(collection, newQuery, config, orderBuilder);
  }
}

extension LimitableExt<S extends FirestoreSchema, T, O extends Record?>
    on Query<S, T, O, dynamic> {
  /// Limits the number of results returned by the query
  Query<S, T, O, int> limit(int limit) {
    final newQuery = query.limit(limit);
    
    // Handle different types of query objects
    if (this is FirestoreCollection<S, T>) {
      return Query<S, T, O, int>(collection, newQuery, null, null);
    } else {
      return Query<S, T, O, int>(collection, newQuery, _orderByConfig, _orderByBuilder);
    }
  }

  Query<S, T, O, int> limitToLast(int limit) {
    final newQuery = query.limitToLast(limit);
    return Query<S, T, O, int>(collection, newQuery, _orderByConfig, _orderByBuilder);
  }
}

extension PatchableExt<S extends FirestoreSchema, T, R>
    on Query<S, T, dynamic, dynamic> {
  /// Patches the query with a new collection
  Future<void> patch(
    List<UpdateOperation> Function(UpdateBuilder<T> patchBuilder)
    patchBuilder,
  ) async {
    return QueryHandler.patch(query,
      collection.documentIdField,
      collection.converter,
      patchBuilder,
    );
  }
}

extension ModifiableExt<
  S extends FirestoreSchema,
  T,
  R extends Map<String, dynamic>
>
    on Query<S, T, dynamic, dynamic> {
  /// Modifies the query with a new collection
  Future<void> modify(T Function(T docData) modifier) async {
    await QueryHandler.modify(
      query,
      collection.documentIdField,
      collection.converter,
      modifier,
    );
  }

  /// Bulk incremental modify all documents that match this collection with automatic atomic operations
  Future<void> incrementalModify(T Function(T docData) modifier) async {
    await QueryHandler.incrementalModify(
      query,
      collection.documentIdField,
      collection.converter,
      modifier,
    );
  }
}

extension PaginableExt<
  S extends FirestoreSchema,
  T,
  R extends Map<String, dynamic>,
  O extends Record,
  L extends int?
>
    on Query<S, T, O, L> {
  Query<S, T, O, L> startAt(O cursorValues) {
    final valuesList = cursorValues.toList();
    final newQuery = query.startAt(valuesList);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> startAfter(O cursorValues) {
    final valuesList = cursorValues.toList();
    final newQuery = query.startAfter(valuesList);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> endAt(O cursorValues) {
    final valuesList = cursorValues.toList();
    final newQuery = query.endAt(valuesList);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> endBefore(O cursorValues) {
    final valuesList = cursorValues.toList();
    final newQuery = query.endBefore(valuesList);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> startAtObject(T object) {
    final values = _extractValuesWithBuilder(
      object,
      collection.converter,
      _orderByBuilder!,
    );
    final newQuery = query.startAt(values);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> startAfterObject(T object) {
    final values = _extractValuesWithBuilder(
      object,
      collection.converter,
      _orderByBuilder!,
    );
    final newQuery = query.startAfter(values);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> endAtObject(T object) {
    final values = _extractValuesWithBuilder(
      object,
      collection.converter,
      _orderByBuilder!,
    );
    final newQuery = query.endAt(values);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }

  Query<S, T, O, L> endBeforeObject(T object) {
    final values = _extractValuesWithBuilder(
      object,
      collection.converter,
      _orderByBuilder!,
    );
    final newQuery = query.endBefore(values);
    return Query<S, T, O, L>(
      collection,
      newQuery,
      _orderByConfig,
      _orderByBuilder,
    );
  }
}

/// Base class for aggregate operations
abstract class AggregateOperation {
  final String key;
  const AggregateOperation(this.key);
}

/// Count operation
class CountOperation extends AggregateOperation {
  const CountOperation(String key) : super(key);
}

/// Sum operation
class SumOperation extends AggregateOperation {
  final String fieldPath;
  const SumOperation(String key, this.fieldPath) : super(key);
}

/// Average operation
class AverageOperation extends AggregateOperation {
  final String fieldPath;
  const AverageOperation(String key, this.fieldPath) : super(key);
}

/// Strongly-typed aggregate field that knows its numeric type
class TupleAggregateField<T extends num> {
  final String _fieldPath;
  final AggregateFieldSelector _selector;

  const TupleAggregateField(this._fieldPath, this._selector);

  /// Create sum aggregation - returns the correct field type
  T sum() {
    // Check if this is a value selector (second pass) or operation collector (first pass)
    if (_selector is _AggregateValueSelector<dynamic>) {
      final valueSelector = _selector;
      // Find the sum operation for this field and return its result
      final sumOp = valueSelector._operations
          .whereType<SumOperation>()
          .where((op) => op.fieldPath == _fieldPath)
          .firstOrNull;
      if (sumOp != null) {
        final value = valueSelector._results[sumOp.key];
        if (value != null) {
          // Convert from double (Firestore's default numeric type) to the expected type
          if (T == int) {
            return (value as num).toInt() as T;
          } else if (T == double) {
            return (value as num).toDouble() as T;
          } else {
            return value as T;
          }
        }
      }
      return _getDefaultValue();
    } else {
      // First pass: collect operation
      final key = 'sum_${_selector._operations.length}';
      _selector._operations.add(SumOperation(key, _fieldPath));
      return _getDefaultValue();
    }
  }

  /// Create average aggregation - always returns double
  double average() {
    // Check if this is a value selector (second pass) or operation collector (first pass)
    if (_selector is _AggregateValueSelector<dynamic>) {
      final valueSelector = _selector;
      // Find the average operation for this field and return its result
      final avgOp = valueSelector._operations
          .whereType<AverageOperation>()
          .where((op) => op.fieldPath == _fieldPath)
          .firstOrNull;
      if (avgOp != null) {
        final value = valueSelector._results[avgOp.key];
        if (value != null) {
          return (value as num).toDouble();
        }
      }
      return 0.0;
    } else {
      // First pass: collect operation
      final key = 'avg_${_selector._operations.length}';
      _selector._operations.add(AverageOperation(key, _fieldPath));
      return 0.0; // Placeholder
    }
  }

  /// Get default value for the specific numeric type
  T _getDefaultValue() {
    if (T == int) return 0 as T;
    if (T == double) return 0.0 as T;
    if (T == num) return 0 as T;
    throw UnsupportedError('Unsupported numeric type: $T');
  }
}

/// Selector that provides strongly-typed field access for aggregations
class AggregateFieldSelector<T> {
  final List<AggregateOperation> _operations = [];

  /// Get count of documents
  int count() {
    final key = 'count_${_operations.length}';
    _operations.add(CountOperation(key));
    return 0; // Placeholder return value
  }

  // All field accessors are now code-generated by AggregateGenerator
  // No hardcoded field access needed here
}

/// Build aggregate query with support for up to 30 fields
firestore.AggregateQuery _buildAggregateQuery(
  firestore.Query query,
  List<firestore.AggregateField> fields,
) {
  // Create the aggregate query using native Firestore API
  // Firestore supports up to 30 aggregate fields
  if (fields.length > 30) {
    throw ArgumentError(
      'Firestore supports a maximum of 30 aggregate fields, but ${fields.length} were provided.',
    );
  }

  return query.aggregate(
    fields[0],
    fields.length > 1 ? fields[1] : null,
    fields.length > 2 ? fields[2] : null,
    fields.length > 3 ? fields[3] : null,
    fields.length > 4 ? fields[4] : null,
    fields.length > 5 ? fields[5] : null,
    fields.length > 6 ? fields[6] : null,
    fields.length > 7 ? fields[7] : null,
    fields.length > 8 ? fields[8] : null,
    fields.length > 9 ? fields[9] : null,
    fields.length > 10 ? fields[10] : null,
    fields.length > 11 ? fields[11] : null,
    fields.length > 12 ? fields[12] : null,
    fields.length > 13 ? fields[13] : null,
    fields.length > 14 ? fields[14] : null,
    fields.length > 15 ? fields[15] : null,
    fields.length > 16 ? fields[16] : null,
    fields.length > 17 ? fields[17] : null,
    fields.length > 18 ? fields[18] : null,
    fields.length > 19 ? fields[19] : null,
    fields.length > 20 ? fields[20] : null,
    fields.length > 21 ? fields[21] : null,
    fields.length > 22 ? fields[22] : null,
    fields.length > 23 ? fields[23] : null,
    fields.length > 24 ? fields[24] : null,
    fields.length > 25 ? fields[25] : null,
    fields.length > 26 ? fields[26] : null,
    fields.length > 27 ? fields[27] : null,
    fields.length > 28 ? fields[28] : null,
    fields.length > 29 ? fields[29] : null,
  );
}

class _AggregateValueSelector<T> extends AggregateFieldSelector<T> {
  final Map<String, dynamic> _results;
  final List<AggregateOperation> _operations;

  _AggregateValueSelector(this._results, this._operations);

  @override
  int count() {
    // Return the actual count result if available
    for (final entry in _results.entries) {
      if (entry.key == 'count' || entry.key.startsWith('count_')) {
        return entry.value as int? ?? 0;
      }
    }
    return 0;
  }
}

extension AggregatableExt<S extends FirestoreSchema, T>
    on Query<S, T, dynamic, dynamic> {
  /// Returns a count query for the current query
  AggregateQuery<S, T, int> count() {
    final countQuery = query.count();
    return AggregateQuery<S, T, int>(collection, countQuery, [
      CountOperation('count'),
    ], (selector) => selector.count());
  }

  /// Returns a sum query for the specified field
  AggregateQuery<S, T, R> aggregate<R extends Record>(
    R Function(AggregateFieldSelector<T> selector) builder,
  ) {
    // Create the selector and build the aggregate specification
    final selector = AggregateFieldSelector<T>();
    builder(selector); // Call builder to populate operations

    final operations = selector._operations;

    // Build the aggregate query using the operations collected
    final aggregateFields = operations.map((op) {
      if (op is CountOperation) {
        return firestore.count();
      } else if (op is SumOperation) {
        return firestore.sum(op.fieldPath);
      } else if (op is AverageOperation) {
        return firestore.average(op.fieldPath);
      } else {
        throw ArgumentError(
          'Unsupported aggregate operation: ${op.runtimeType}',
        );
      }
    }).toList();

    final aggregateQuery = _buildAggregateQuery(query, aggregateFields);
    return AggregateQuery<S, T, R>(
      collection,
      aggregateQuery,
      operations,
      builder,
    );
  }
}

class AggregateQuery<S extends FirestoreSchema, T, R>
    implements Gettable<R>, Streamable<R> {
  AggregateQuery(this.collection, this.query, this.operations, this._builder);
  final FirestoreCollection<S, T> collection;
  final List<AggregateOperation> operations;
  final firestore.AggregateQuery query;
  final R Function(AggregateFieldSelector<T> selector) _builder;

  /// Executes the aggregate query and returns the result
  Future<R> get() {
    return query.get().then((snapshot) {
      // Build the result record from the snapshot
      return _buildResultRecordFromSnapshot(operations, snapshot, _builder);
    });
  }

  @override
  Stream<R> get stream =>
      lazyBroadcast(
            () => (query.query as firestore.Query<Map<String, dynamic>>)
                .snapshots(),
          )
          .map(
            (snapshot) => processQuerySnapshot(
              snapshot,
              collection.converter.fromJson,
              collection.documentIdField,
            ),
          )
          .map(
            (data) => _calculateAggregationsFromSnapshot(
              data,
              operations,
              collection.converter.toJson,
            ),
          )
          .map((data) {
            final valueSelector = _AggregateValueSelector<T>(data, operations);
            final recordSpec = _builder(valueSelector);
            return _buildResultRecord(recordSpec, data, operations, _builder);
          });
}

R _buildResultRecordFromSnapshot<T, R>(
  List<AggregateOperation> operations,
  firestore.AggregateQuerySnapshot snapshot,
  R Function(AggregateFieldSelector<T> selector) builder,
) {
  final results = <String, dynamic>{};

  // Use results from native aggregate query
  for (final op in operations) {
    if (op is CountOperation) {
      results[op.key] = snapshot.count ?? 0;
    } else if (op is SumOperation) {
      results[op.key] = snapshot.getSum(op.fieldPath) ?? 0;
    } else if (op is AverageOperation) {
      results[op.key] = snapshot.getAverage(op.fieldPath) ?? 0.0;
    }
  }

  // Create a dummy record spec to get the structure
  final selector = AggregateFieldSelector<T>();
  final recordSpec = builder(selector);

  return _buildResultRecord(recordSpec, results, operations, builder);
}

R _buildResultRecord<T, R>(
  R template,
  Map<String, dynamic> results,
  List<AggregateOperation> operations,
  R Function(AggregateFieldSelector<T> selector) builder,
) {
  // Create a value selector that returns actual computed results
  final valueSelector = _AggregateValueSelector<T>(results, operations);

  // Re-call the builder function with the value selector to get the final record
  return builder(valueSelector);
}

/// Applies a filter to the given Firestore query
firestore.Query<R> applyFilterToQuery<R>(
  firestore.Query<R> query,
  FirestoreFilter filter,
) {
  if (filter.type == FilterType.field) {
    final field = filter.field!;
    final operator = filter.operator!;
    final value = filter.value;

    switch (operator) {
      case FilterOperator.isEqualTo:
        return query.where(field, isEqualTo: value);
      case FilterOperator.isNotEqualTo:
        return query.where(field, isNotEqualTo: value);
      case FilterOperator.isLessThan:
        return query.where(field, isLessThan: value);
      case FilterOperator.isLessThanOrEqualTo:
        return query.where(field, isLessThanOrEqualTo: value);
      case FilterOperator.isGreaterThan:
        return query.where(field, isGreaterThan: value);
      case FilterOperator.isGreaterThanOrEqualTo:
        return query.where(field, isGreaterThanOrEqualTo: value);
      case FilterOperator.arrayContains:
        return query.where(field, arrayContains: value);
      case FilterOperator.arrayContainsAny:
        return query.where(field, arrayContainsAny: value);
      case FilterOperator.whereIn:
        return query.where(field, whereIn: value);
      case FilterOperator.whereNotIn:
        return query.where(field, whereNotIn: value);
    }
  } else if (filter.type == FilterType.and) {
    var newQuery = query;
    for (var subFilter in filter.filters!) {
      newQuery = applyFilterToQuery(newQuery, subFilter);
    }
    return newQuery;
  } else if (filter.type == FilterType.or) {
    // Use Firestore's Filter.or() for proper OR logic
    final filters = filter.filters!
        .map((f) => _buildFirestoreFilter(f))
        .toList();
    if (filters.isEmpty)
      throw ArgumentError('OR filter must have at least one condition');
    if (filters.length == 1) return query.where(filters.first);
    return query.where(_buildOrFilter(filters));
  }
  throw ArgumentError('Unsupported filter type: ${filter.type}');
}

/// Build a Firestore Filter from our FirestoreFilter
firestore.Filter _buildFirestoreFilter(FirestoreFilter filter) {
  switch (filter.type) {
    case FilterType.field:
      return _buildFieldFilter(filter);
    case FilterType.and:
      final filters = filter.filters!.map(_buildFirestoreFilter).toList();
      if (filters.isEmpty)
        throw ArgumentError('AND filter must have at least one condition');
      if (filters.length == 1) return filters.first;
      return _buildAndFilter(filters);
    case FilterType.or:
      final filters = filter.filters!.map(_buildFirestoreFilter).toList();
      if (filters.isEmpty)
        throw ArgumentError('OR filter must have at least one condition');
      if (filters.length == 1) return filters.first;
      return _buildOrFilter(filters);
  }
}

/// Build a single field Filter
firestore.Filter _buildFieldFilter(FirestoreFilter filter) {
  switch (filter.operator!) {
    case FilterOperator.isEqualTo:
      return firestore.Filter(filter.field!, isEqualTo: filter.value);
    case FilterOperator.isNotEqualTo:
      return firestore.Filter(filter.field!, isNotEqualTo: filter.value);
    case FilterOperator.isLessThan:
      return firestore.Filter(filter.field!, isLessThan: filter.value);
    case FilterOperator.isLessThanOrEqualTo:
      return firestore.Filter(filter.field!, isLessThanOrEqualTo: filter.value);
    case FilterOperator.isGreaterThan:
      return firestore.Filter(filter.field!, isGreaterThan: filter.value);
    case FilterOperator.isGreaterThanOrEqualTo:
      return firestore.Filter(
        filter.field!,
        isGreaterThanOrEqualTo: filter.value,
      );
    case FilterOperator.arrayContains:
      return firestore.Filter(filter.field!, arrayContains: filter.value);
    case FilterOperator.arrayContainsAny:
      return firestore.Filter(filter.field!, arrayContainsAny: filter.value);
    case FilterOperator.whereIn:
      return firestore.Filter(filter.field!, whereIn: filter.value);
    case FilterOperator.whereNotIn:
      return firestore.Filter(filter.field!, whereNotIn: filter.value);
  }
}

/// Build Filter.or() with the correct API signature
firestore.Filter _buildOrFilter(List<firestore.Filter> filters) {
  if (filters.length < 2)
    throw ArgumentError('OR filter needs at least 2 filters');

  // Use the specific API signature for Filter.or()
  return firestore.Filter.or(
    filters[0],
    filters[1],
    filters.length > 2 ? filters[2] : null,
    filters.length > 3 ? filters[3] : null,
    filters.length > 4 ? filters[4] : null,
    filters.length > 5 ? filters[5] : null,
    filters.length > 6 ? filters[6] : null,
    filters.length > 7 ? filters[7] : null,
    filters.length > 8 ? filters[8] : null,
    filters.length > 9 ? filters[9] : null,
    filters.length > 10 ? filters[10] : null,
    filters.length > 11 ? filters[11] : null,
    filters.length > 12 ? filters[12] : null,
    filters.length > 13 ? filters[13] : null,
    filters.length > 14 ? filters[14] : null,
    filters.length > 15 ? filters[15] : null,
    filters.length > 16 ? filters[16] : null,
    filters.length > 17 ? filters[17] : null,
    filters.length > 18 ? filters[18] : null,
    filters.length > 19 ? filters[19] : null,
    filters.length > 20 ? filters[20] : null,
    filters.length > 21 ? filters[21] : null,
    filters.length > 22 ? filters[22] : null,
    filters.length > 23 ? filters[23] : null,
    filters.length > 24 ? filters[24] : null,
    filters.length > 25 ? filters[25] : null,
    filters.length > 26 ? filters[26] : null,
    filters.length > 27 ? filters[27] : null,
    filters.length > 28 ? filters[28] : null,
    filters.length > 29 ? filters[29] : null,
  );
}

/// Build Filter.and() with the correct API signature
firestore.Filter _buildAndFilter(List<firestore.Filter> filters) {
  if (filters.length < 2)
    throw ArgumentError('AND filter needs at least 2 filters');

  // Use the specific API signature for Filter.and()
  return firestore.Filter.and(
    filters[0],
    filters[1],
    filters.length > 2 ? filters[2] : null,
    filters.length > 3 ? filters[3] : null,
    filters.length > 4 ? filters[4] : null,
    filters.length > 5 ? filters[5] : null,
    filters.length > 6 ? filters[6] : null,
    filters.length > 7 ? filters[7] : null,
    filters.length > 8 ? filters[8] : null,
    filters.length > 9 ? filters[9] : null,
    filters.length > 10 ? filters[10] : null,
    filters.length > 11 ? filters[11] : null,
    filters.length > 12 ? filters[12] : null,
    filters.length > 13 ? filters[13] : null,
    filters.length > 14 ? filters[14] : null,
    filters.length > 15 ? filters[15] : null,
    filters.length > 16 ? filters[16] : null,
    filters.length > 17 ? filters[17] : null,
    filters.length > 18 ? filters[18] : null,
    filters.length > 19 ? filters[19] : null,
    filters.length > 20 ? filters[20] : null,
    filters.length > 21 ? filters[21] : null,
    filters.length > 22 ? filters[22] : null,
    filters.length > 23 ? filters[23] : null,
    filters.length > 24 ? filters[24] : null,
    filters.length > 25 ? filters[25] : null,
    filters.length > 26 ? filters[26] : null,
    filters.length > 27 ? filters[27] : null,
    filters.length > 28 ? filters[28] : null,
    filters.length > 29 ? filters[29] : null,
  );
}

/// Calculate aggregations from snapshot for streaming
Map<String, dynamic> _calculateAggregationsFromSnapshot<T>(
  List<T> snapshot,
  List<AggregateOperation> operations,
  Map<String, dynamic> Function(T) toJson,
) {
  final results = <String, dynamic>{};

  // Count operations - can use snapshot length
  final countOps = operations.whereType<CountOperation>().toList();
  final count = snapshot.length;
  for (final op in countOps) {
    results[op.key] = count;
  }

  // For sum/average, parse documents manually
  final sumOps = operations.whereType<SumOperation>().toList();
  final avgOps = operations.whereType<AverageOperation>().toList();

  if (sumOps.isNotEmpty || avgOps.isNotEmpty) {
    // Calculate sums
    for (final op in sumOps) {
      results[op.key] = _calculateSum(snapshot, op.fieldPath, toJson);
    }

    // Calculate averages
    for (final op in avgOps) {
      results[op.key] = _calculateAverage(snapshot, op.fieldPath, toJson);
    }
  }

  return results;
}

/// Calculate sum for a field path
num _calculateSum<T>(
  List<T> documents,
  String fieldPath,
  Map<String, dynamic> Function(T) toJson,
) {
  num total = 0;
  for (final doc in documents) {
    final json = toJson(doc);
    final value = _getNestedValue(json, fieldPath);
    if (value is num) {
      total += value;
    }
  }
  return total;
}

/// Calculate average for a field path
double _calculateAverage<T>(
  List<T> documents,
  String fieldPath,
  Map<String, dynamic> Function(T) toJson,
) {
  num total = 0;
  int count = 0;
  for (final doc in documents) {
    final json = toJson(doc);
    final value = _getNestedValue(json, fieldPath);
    if (value is num) {
      total += value;
      count++;
    }
  }
  return count > 0 ? total / count : 0.0;
}

/// Get nested value from JSON using dot notation
dynamic _getNestedValue(Map<String, dynamic> json, String fieldPath) {
  final parts = fieldPath.split('.');
  dynamic current = json;
  for (final part in parts) {
    if (current is Map<String, dynamic> && current.containsKey(part)) {
      current = current[part];
    } else {
      return null;
    }
  }
  return current;
}

/// Smart value extraction using the SAME builder function as orderBy
/// This ensures perfect consistency and type safety
List<dynamic> _extractValuesWithBuilder<T, O>(
  T object,
  ModelConverter<T> converter,
  O Function(OrderByFieldSelector<T>) orderByBuilder,
) {
  // Convert object to Map for extraction
  final objectMap = converter.toJson(object);

  // Create extraction-mode selector with the same object
  final extractionSelector = OrderByFieldSelector<T>(
    isExtractionMode: true,
    sourceObject: objectMap,
  );

  // Reuse the SAME builder function to extract values!
  // This guarantees perfect consistency with orderBy
  orderByBuilder(extractionSelector);

  return extractionSelector.extractedValues;
}
