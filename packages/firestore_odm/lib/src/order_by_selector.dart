import 'package:cloud_firestore/cloud_firestore.dart';

/// Selector that provides strongly-typed field access for orderBy operations
/// Returns field types to capture tuple types for pagination cursors
class OrderByFieldSelector<T> {
  final String prefix;
  final List<OrderByFieldInfo> _fields;
  
  // Value extraction mode - extracts actual values from object
  final bool _isExtractionMode;
  final Map<String, dynamic>? _sourceObject;
  final List<dynamic> _extractedValues = [];

  /// Create a field selector with optional prefix for nested fields
  /// If parentFields is provided, nested selectors will share the same field collection
  OrderByFieldSelector({
    this.prefix = '',
    List<OrderByFieldInfo>? parentFields,
    bool isExtractionMode = false,
    Map<String, dynamic>? sourceObject,
  }) : _fields = parentFields ?? <OrderByFieldInfo>[],
       _isExtractionMode = isExtractionMode,
       _sourceObject = sourceObject;

  /// Get the collected orderBy fields
  List<OrderByFieldInfo> get fields => _fields;
  
  /// Get extracted values (only available in extraction mode)
  List<dynamic> get extractedValues => _extractedValues;
  
  /// Public getters for extraction mode state (needed by generated extensions)
  bool get isExtractionMode => _isExtractionMode;
  Map<String, dynamic>? get sourceObject => _sourceObject;

  /// Add a field to the orderBy configuration
  /// Returns the field type to enable tuple type inference OR extracted value
  R addField<R>(dynamic fieldPath, bool descending, Type fieldType) {
    String fullPath;
    if (fieldPath is String) {
      fullPath = prefix.isEmpty ? fieldPath : '$prefix$fieldPath';
    } else {
      // Handle FieldPath objects (e.g., FieldPath.documentId)
      fullPath = fieldPath.toString();
    }
    
    if (_isExtractionMode) {
      // Extract actual value from source object
      if (fieldPath == FieldPath.documentId) {
        // For document ID, extract from the object's id field
        final value = _sourceObject!['id'] ?? _sourceObject!['_id'] ?? _sourceObject!.keys.first;
        _extractedValues.add(value);
        return value as R;
      } else {
        final value = _extractNestedValue(_sourceObject!, fullPath);
        _extractedValues.add(value);
        return value as R;
      }
    } else {
      // Normal orderBy mode - collect field info and return type placeholder
      if (fieldPath == FieldPath.documentId) {
        // For document ID, store the actual FieldPath.documentId object
        _fields.add(OrderByFieldInfo(FieldPath.documentId, descending, fieldType));
      } else {
        _fields.add(OrderByFieldInfo(fullPath, descending, fieldType));
      }
      // Return default value of the type for type inference
      switch (fieldType) {
        case == int:
          return 0 as R;
        case == double:
          return 0.0 as R;
        case == String:
          return '' as R;
        case == bool:
          return false as R;
        case == DateTime:
          return DateTime.now() as R;
        default:
          // For other types, return null cast to R
          return null as R;
      }
    }
  }
  
  /// Extract nested value from object map using dot notation
  static dynamic _extractNestedValue(Map<String, dynamic> map, String fieldPath) {
    final parts = fieldPath.split('.');
    dynamic current = map;
    
    for (final part in parts) {
      if (current is Map<String, dynamic> && current.containsKey(part)) {
        current = current[part];
      } else {
        return null;
      }
    }
    
    return current;
  }

  // Field accessor methods are code-generated by OrderByGenerator
  // Each method returns the field type (int, String, etc.) to build the tuple type
  // Example generated methods:
  // int age([bool descending = false]) => addField('age', descending, int);
  // String name([bool descending = false]) => addField('name', descending, String);
}

/// Information about an orderBy field
class OrderByFieldInfo {
  final dynamic fieldPath; // Can be String or FieldPath
  final bool descending;
  final Type fieldType;

  const OrderByFieldInfo(this.fieldPath, this.descending, this.fieldType);

  @override
  String toString() => 'OrderByFieldInfo($fieldPath, descending: $descending, type: $fieldType)';
}

/// Configuration for orderBy operations used in pagination
class OrderByConfiguration {
  final List<OrderByFieldInfo> fields;

  const OrderByConfiguration(this.fields);

  bool get isEmpty => fields.isEmpty;
  List<Type> get fieldTypes => fields.map((f) => f.fieldType).toList();

  @override
  String toString() => 'OrderByConfiguration($fields)';
}