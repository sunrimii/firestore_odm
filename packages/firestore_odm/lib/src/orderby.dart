
import 'package:cloud_firestore/cloud_firestore.dart' as firestore;
import 'package:firestore_odm/src/interfaces/gettable.dart';
import 'package:firestore_odm/src/interfaces/limitable.dart';
import 'package:firestore_odm/src/interfaces/orderable.dart';
import 'package:firestore_odm/src/interfaces/paginatable.dart';
import 'package:firestore_odm/src/interfaces/streamable.dart';
import 'package:firestore_odm/src/model_converter.dart';
import 'package:firestore_odm/src/orderby.dart';
import 'package:firestore_odm/src/pagination.dart';
import 'package:firestore_odm/src/recordHelper.dart';
import 'package:firestore_odm/src/schema.dart';
import 'package:firestore_odm/src/services/update_operations_service.dart';

class OrderByFieldSelector<T> {
  final String prefix;
  final List<OrderByFieldInfo> _fields;

  // Value extraction mode - extracts actual values from object
  final bool _isExtractionMode;
  final Map<String, dynamic>? _sourceObject;
  final List<dynamic> _extractedValues = [];

  /// Create a field selector with optional prefix for nested fields
  /// If parentFields is provided, nested selectors will share the same field collection
  OrderByFieldSelector({
    this.prefix = '',
    List<OrderByFieldInfo>? parentFields,
    bool isExtractionMode = false,
    Map<String, dynamic>? sourceObject,
  }) : _fields = parentFields ?? <OrderByFieldInfo>[],
       _isExtractionMode = isExtractionMode,
       _sourceObject = sourceObject;

  /// Get the collected orderBy fields
  List<OrderByFieldInfo> get fields => _fields;

  /// Get extracted values (only available in extraction mode)
  List<dynamic> get extractedValues => _extractedValues;

  /// Public getters for extraction mode state (needed by generated extensions)
  bool get isExtractionMode => _isExtractionMode;
  Map<String, dynamic>? get sourceObject => _sourceObject;

  /// Add a field to the orderBy configuration
  /// Returns the field type to enable tuple type inference OR extracted value
  R addField<R>(dynamic fieldPath, bool descending, Type fieldType) {
    String fullPath;
    if (fieldPath is String) {
      fullPath = prefix.isEmpty ? fieldPath : '$prefix$fieldPath';
    } else {
      // Handle FieldPath objects (e.g., FieldPath.documentId)
      fullPath = fieldPath.toString();
    }

    if (_isExtractionMode) {
      // Extract actual value from source object
      if (fieldPath == firestore.FieldPath.documentId) {
        // For document ID, extract from the object's id field
        final value =
            _sourceObject!['id'] ??
            _sourceObject['_id'] ??
            _sourceObject.keys.first;
        _extractedValues.add(value);
        return value as R;
      } else {
        final value = _extractNestedValue(_sourceObject!, fullPath);
        _extractedValues.add(value);
        return value as R;
      }
    } else {
      // Normal orderBy mode - collect field info and return type placeholder
      if (fieldPath == firestore.FieldPath.documentId) {
        // For document ID, store the actual FieldPath.documentId object
        _fields.add(
          OrderByFieldInfo(
            firestore.FieldPath.documentId,
            descending,
            fieldType,
          ),
        );
      } else {
        _fields.add(OrderByFieldInfo(fullPath, descending, fieldType));
      }
      // Return default value of the type for type inference
      switch (fieldType) {
        case == int:
          return 0 as R;
        case == double:
          return 0.0 as R;
        case == String:
          return '' as R;
        case == bool:
          return false as R;
        case == DateTime:
          return DateTime.now() as R;
        default:
          // For other types, return null cast to R
          return null as R;
      }
    }
  }

  /// Extract nested value from object map using dot notation
  static dynamic _extractNestedValue(
    Map<String, dynamic> map,
    String fieldPath,
  ) {
    final parts = fieldPath.split('.');
    dynamic current = map;

    for (final part in parts) {
      if (current is Map<String, dynamic> && current.containsKey(part)) {
        current = current[part];
      } else {
        return null;
      }
    }

    return current;
  }

  // Field accessor methods are code-generated by OrderByGenerator
  // Each method returns the field type (int, String, etc.) to build the tuple type
  // Example generated methods:
  // int age([bool descending = false]) => addField('age', descending, int);
  // String name([bool descending = false]) => addField('name', descending, String);
}

/// Information about an orderBy field for pagination
class OrderByFieldInfo {
  final dynamic fieldPath; // Can be String or FieldPath
  final bool descending;
  final Type fieldType;

  const OrderByFieldInfo(this.fieldPath, this.descending, this.fieldType);

  @override
  String toString() =>
      'OrderByFieldInfo($fieldPath, desc: $descending, type: $fieldType)';
}

typedef OrderByBuilderFunction<T, O extends Record> =
    O Function(OrderByFieldSelector<T> selector);

/// Container for orderBy configuration used in pagination
class OrderByConfiguration<T, O extends Record> {
  final List<OrderByFieldInfo> fields;
  final OrderByBuilderFunction<T, O> builder;

  const OrderByConfiguration(this.fields, this.builder);

  /// Check if this configuration is empty
  bool get isEmpty => fields.isEmpty;

  /// Get field types as a tuple-like representation
  List<Type> get fieldTypes => fields.map((f) => f.fieldType).toList();

  @override
  String toString() => 'OrderByConfiguration(${fields.join(', ')})';
}


abstract class QueryOrderbyHandler {
  static OrderByConfiguration<T, O> buildOrderBy<T, O extends Record>(
    O Function(OrderByFieldSelector<T> selector) orderBuilder,
  ) {
    final selector = OrderByFieldSelector<T>();

    // Call the order builder to populate the selector
    orderBuilder(selector);

    final pgFields = selector.fields
        .map((f) => OrderByFieldInfo(f.fieldPath, f.descending, f.fieldType))
        .toList();
    return OrderByConfiguration(pgFields, orderBuilder);
  }

  static firestore.Query<Map<String, dynamic>> applyOrderBy<
    T,
    O extends Record
  >(firestore.Query<Map<String, dynamic>> query, OrderByConfiguration config) {
    // Build the actual Firestore query from the collected fields
    firestore.Query<Map<String, dynamic>> newQuery = query;
    for (final field in config.fields) {
      newQuery = newQuery.orderBy(
        field.fieldPath,
        descending: field.descending,
      );
    }

    return newQuery;
  }
}


class OrderedQuery<S extends FirestoreSchema, T, O extends Record>
    implements
        Gettable<List<T>>,
        Streamable<List<T>>,
        Paginatable<T, O>,
        Limitable {
  final ModelConverter<T> _converter;

  final String _documentIdField;

  /// The underlying Firestore query
  final firestore.Query<Map<String, dynamic>> _query;

  final OrderByConfiguration<T, O> _orderByConfig;

  const OrderedQuery(
    firestore.Query<Map<String, dynamic>> _query,
    ModelConverter<T> _converter,
    String _documentIdField,
    OrderByConfiguration<T, O> orderByConfig,
  ) : _query = _query,
      _converter = _converter,
      _documentIdField = _documentIdField,
      _orderByConfig = orderByConfig;

  @override
  Future<List<T>> get() =>
      QueryHandler.get(_query, _converter.fromJson, _documentIdField);

  @override
  Stream<List<T>?> get stream =>
      QueryHandler.stream(_query, _converter.fromJson, _documentIdField);

  @override
  OrderedQuery<S, T, O> limit(int limit) {
    final newQuery = QueryLimitHandler.applyLimit(_query, limit);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> limitToLast(int limit) {
    final newQuery = QueryLimitHandler.applyLimitToLast(_query, limit);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> endAt(O cursorValues) {
    final cursors = QueryPaginationHandler.build(cursorValues);
    final newQuery = QueryPaginationHandler.applyEndAt(_query, cursors);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> endAtObject(T object) {
    final values = QueryPaginationHandler.buildValuesFromObject(
      object,
      _converter,
      _orderByConfig.builder,
    );
    final newQuery = QueryPaginationHandler.applyEndAt(_query, values);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> endBefore(O cursorValues) {
    final cursors = QueryPaginationHandler.build(cursorValues);
    final newQuery = QueryPaginationHandler.applyEndBefore(_query, cursors);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> endBeforeObject(T object) {
    final values = QueryPaginationHandler.buildValuesFromObject(
      object,
      _converter,
      _orderByConfig.builder,
    );
    final newQuery = QueryPaginationHandler.applyEndBefore(_query, values);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> startAfter(O cursorValues) {
    final cursors = QueryPaginationHandler.build(cursorValues);
    final newQuery = QueryPaginationHandler.applyStartAfter(_query, cursors);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> startAfterObject(T object) {
    final values = QueryPaginationHandler.buildValuesFromObject(
      object,
      _converter,
      _orderByConfig.builder,
    );
    final newQuery = QueryPaginationHandler.applyStartAfter(_query, values);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> startAt(O cursorValues) {
    final cursors = QueryPaginationHandler.build(cursorValues);
    final newQuery = QueryPaginationHandler.applyStartAt(_query, cursors);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }

  @override
  OrderedQuery<S, T, O> startAtObject(T object) {
    final values = QueryPaginationHandler.buildValuesFromObject(
      object,
      _converter,
      _orderByConfig.builder,
    );
    final newQuery = QueryPaginationHandler.applyStartAt(_query, values);
    return OrderedQuery<S, T, O>(
      newQuery,
      _converter,
      _documentIdField,
      _orderByConfig,
    );
  }
}
