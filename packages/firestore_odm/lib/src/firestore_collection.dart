import 'package:cloud_firestore/cloud_firestore.dart' as firestore;
import 'package:firestore_odm/firestore_odm.dart';
import 'package:firestore_odm/src/interfaces/aggregatable.dart';
import 'package:firestore_odm/src/interfaces/deletable.dart';
import 'package:firestore_odm/src/interfaces/filterable.dart';
import 'package:firestore_odm/src/interfaces/gettable.dart';
import 'package:firestore_odm/src/interfaces/insertable.dart';
import 'package:firestore_odm/src/interfaces/limitable.dart';
import 'package:firestore_odm/src/interfaces/modifiable.dart';
import 'package:firestore_odm/src/interfaces/orderable.dart';
import 'package:firestore_odm/src/interfaces/patchable.dart';
import 'package:firestore_odm/src/interfaces/streamable.dart';
import 'package:firestore_odm/src/interfaces/updatable.dart';
import 'package:firestore_odm/src/interfaces/upsertable.dart';
import 'package:firestore_odm/src/services/update_operations_service.dart';
import 'package:flutter/material.dart';

/// A wrapper around Firestore CollectionReference with type safety and caching
abstract class FirestoreCollection<S extends FirestoreSchema, T>
    implements
        Gettable<List<T>>,
        Streamable<List<T>>,
        Insertable<T>,
        Updatable<T>,
        Upsertable<T>,
        Orderable<T>,
        Filterable<T>,
        Patchable<T>,
        Modifiable<T>,
        Aggregatable<S, T>,
        Limitable,
        Deletable {
  /// The underlying Firestore collection reference
  final firestore.CollectionReference<Map<String, dynamic>> query;

  /// Model converter for data transformation
  final FirestoreConverter<T, Map<String, dynamic>> converter;

  /// Document ID field name (detected from model analysis)
  final String documentIdField;

  /// Creates a new FirestoreCollection instance
  const FirestoreCollection({
    required this.query,
    required this.converter,
    required this.documentIdField,
  });

  /// Gets a document reference with the specified ID
  /// Documents are cached to ensure consistency
  /// Usage: users('id')
  FirestoreDocument<S, T> call(String id) => doc(id);

  FirestoreDocument<S, T> doc(String id);

  /// Upsert a document using the id field as document ID
  Future<void> upsert(T value) =>
      CollectionHandler.upsert(query, value, converter.toJson, documentIdField);

  /// Insert a new document using the id field as document ID
  /// Use FirestoreODM.autoGeneratedId for server-generated unique IDs
  /// Fails if document already exists (when ID is specified)
  Future<void> insert(T value) =>
      CollectionHandler.insert(query, value, converter.toJson, documentIdField);

  /// Update an existing document using the id field as document ID
  /// Fails if document doesn't exist
  @override
  Future<void> update(T value) =>
      CollectionHandler.update(query, value, converter.toJson, documentIdField);

  @override
  Future<List<T>> get() =>
      CollectionHandler.get<T>(query, converter.fromJson, documentIdField);

  @override
  Stream<List<T>> get stream =>
      QueryHandler.stream(query, converter.fromJson, documentIdField);

  @override
  OrderedQuery<S, T, O> orderBy<O extends Record>(
    O Function(OrderByFieldSelector<T> selector) orderBuilder,
  ) {
    final config = QueryOrderbyHandler.buildOrderBy(
      orderBuilder,
      documentIdField,
    );
    final newQuery = QueryOrderbyHandler.applyOrderBy(query, config);
    return OrderedQuery(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
      config,
    );
  }

  @override
  Query<S, T> where(FilterBuilder<T> filterBuilder) {
    final filter = QueryFilterHandler.buildFilter(filterBuilder);
    final newQuery = QueryFilterHandler.applyFilter(query, filter);
    return Query<S, T>(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
    );
  }

  @override
  Query<S, T> limit(int limit) {
    final newQuery = QueryLimitHandler.applyLimit(query, limit);
    return Query<S, T>(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
    );
  }

  @override
  Query<S, T> limitToLast(int limit) {
    final newQuery = QueryLimitHandler.applyLimitToLast(query, limit);
    return Query<S, T>(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
    );
  }

  // @override
  // Future<void> patch(PatchBuilder<T> patchBuilder) {
  //   final operations = patchBuilder(_updateBuilder);
  //   return QueryHandler.patch(query, documentIdField, operations);
  // }

  @override
  AggregateQuery<S, T, R> aggregate<R extends Record>(
    R Function(RootAggregateFieldSelector<T> selector) builder,
  ) {
    final config = QueryAggregatableHandler.buildAggregate(builder);
    final newQuery = QueryAggregatableHandler.applyAggregate(
      query,
      config.operations,
    );
    return AggregateQuery(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
      config,
    );
  }

  @override
  AggregateCountQuery count() {
    final newQuery = QueryAggregatableHandler.applyCount(query);
    return AggregateCountQuery(newQuery);
  }

  @override
  Future<void> modify(ModifierBuilder<T> modifier, {bool atomic = true}) =>
      QueryHandler.modify(
        query,
        documentIdField,
        converter.toJson,
        converter.fromJson,
        modifier,
        atomic: atomic,
      );

  @override
  Future<void> delete() => QueryHandler.delete(query);
}
