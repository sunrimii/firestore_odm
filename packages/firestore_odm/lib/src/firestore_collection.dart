import 'package:cloud_firestore/cloud_firestore.dart' as firestore;
import 'package:firestore_odm/firestore_odm.dart';
import 'package:firestore_odm/src/interfaces/aggregatable.dart';
import 'package:firestore_odm/src/interfaces/deletable.dart';
import 'package:firestore_odm/src/interfaces/filterable.dart';
import 'package:firestore_odm/src/interfaces/gettable.dart';
import 'package:firestore_odm/src/interfaces/insertable.dart';
import 'package:firestore_odm/src/interfaces/limitable.dart';
import 'package:firestore_odm/src/interfaces/modifiable.dart';
import 'package:firestore_odm/src/interfaces/orderable.dart';
import 'package:firestore_odm/src/interfaces/patchable.dart';
import 'package:firestore_odm/src/interfaces/streamable.dart';
import 'package:firestore_odm/src/interfaces/updatable.dart';
import 'package:firestore_odm/src/interfaces/upsertable.dart';

/// A wrapper around Firestore CollectionReference with type safety and caching
class FirestoreCollection<S extends FirestoreSchema, T, Path extends Record, P extends PatchBuilder<T>, F extends RootFilterSelector<T>>
    implements
        Gettable<List<T>>,
        Streamable<List<T>>,
        Insertable<T>,
        Updatable<T>,
        Upsertable<T>,
        Orderable<T>,
        Filterable<T>,
        Patchable<T>,
        Modifiable<T>,
        Aggregatable<S, T>,
        Limitable,
        Deletable {
  /// The underlying Firestore collection reference
  final firestore.CollectionReference<Map<String, dynamic>> query;

  /// Model converter for data transformation
  final FirestoreConverter<T, Map<String, dynamic>> converter;

  /// Document ID field name (detected from model analysis)
  final String documentIdField;

  final P _patchBuilder;

  final F _filterBuilder;

  /// Creates a new FirestoreCollection instance
  const FirestoreCollection({
    required this.query,
    required this.converter,
    required this.documentIdField,
    required P patchBuilder,
    required F filterBuilder,
  })  : _patchBuilder = patchBuilder,
        _filterBuilder = filterBuilder;

  /// Gets a document reference with the specified ID
  /// Documents are cached to ensure consistency
  /// Usage: users('id')
  FirestoreDocument<S, T, Path, P> call(String id) => doc(id);

  FirestoreDocument<S, T, Path, P> doc(String id) =>
      FirestoreDocument<S, T, Path, P>(
        ref: query.doc(id),
        converter: converter,
        documentIdField: documentIdField,
        patchBuilder: _patchBuilder,
      );

  /// Upsert a document using the id field as document ID
  Future<void> upsert(T value) =>
      CollectionHandler.upsert(query, value, converter.toJson, documentIdField);

  /// Insert a new document using the id field as document ID
  /// Use FirestoreODM.autoGeneratedId for server-generated unique IDs
  /// Fails if document already exists (when ID is specified)
  Future<void> insert(T value) =>
      CollectionHandler.insert(query, value, converter.toJson, documentIdField);

  /// Update an existing document using the id field as document ID
  /// Fails if document doesn't exist
  @override
  Future<void> update(T value) =>
      CollectionHandler.update(query, value, converter.toJson, documentIdField);

  @override
  Future<List<T>> get() =>
      CollectionHandler.get<T>(query, converter.fromJson, documentIdField);

  @override
  Stream<List<T>> get stream =>
      QueryHandler.stream(query, converter.fromJson, documentIdField);

  @override
  OrderedQuery<S, T, O> orderBy<O extends Record>(
    O Function(OrderByFieldSelector<T> selector) orderBuilder,
  ) {
    final config = QueryOrderbyHandler.buildOrderBy(
      orderBuilder,
      documentIdField,
    );
    final newQuery = QueryOrderbyHandler.applyOrderBy(query, config);
    return OrderedQuery(
      newQuery,
      converter,
      documentIdField,
      config,
    );
  }

  @override
  Query<S, T, F> where(FirestoreFilter Function(F selector) filterFunc) {
    final filter = filterFunc(_filterBuilder);
    final newQuery = QueryFilterHandler.applyFilter(query, filter);
    return Query<S, T, F>(
      query: newQuery,
      converter: converter,
      documentIdField: documentIdField,
      filterBuilder: _filterBuilder,
    );
  }

  @override
  Query<S, T, F> limit(int limit) {
    final newQuery = QueryLimitHandler.applyLimit(query, limit);
    return Query<S, T, F>(
      query: newQuery,
      converter: converter,
      documentIdField: documentIdField,
      filterBuilder: _filterBuilder,
    );
  }

  @override
  Query<S, T, F> limitToLast(int limit) {
    final newQuery = QueryLimitHandler.applyLimitToLast(query, limit);
    return Query<S, T, F>(
      query: newQuery,
      converter: converter,
      documentIdField: documentIdField,
      filterBuilder: _filterBuilder,
    );
  }

  @override
  Future<void> patch(List<UpdateOperation> Function(P patches) patches) {
    final operations = patches(_patchBuilder);
    return QueryHandler.patch(query, operations);
  }

  @override
  AggregateQuery<S, T, R> aggregate<R extends Record>(
    R Function(RootAggregateFieldSelector<T> selector) builder,
  ) {
    final config = QueryAggregatableHandler.buildAggregate(builder);
    final newQuery = QueryAggregatableHandler.applyAggregate(
      query,
      config.operations,
    );
    return AggregateQuery(
      newQuery,
      converter.toJson,
      converter.fromJson,
      documentIdField,
      config,
    );
  }

  @override
  AggregateCountQuery count() {
    final newQuery = QueryAggregatableHandler.applyCount(query);
    return AggregateCountQuery(newQuery);
  }

  @override
  Future<void> modify(ModifierBuilder<T> modifier, {bool atomic = true}) =>
      QueryHandler.modify(
        query,
        documentIdField,
        converter.toJson,
        converter.fromJson,
        modifier,
        atomic: atomic,
      );

  @override
  Future<void> delete() => QueryHandler.delete(query);
}
