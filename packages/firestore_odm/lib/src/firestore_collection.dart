import 'package:cloud_firestore/cloud_firestore.dart' as firestore;
import 'package:firestore_odm/firestore_odm.dart';
import 'package:firestore_odm/src/interfaces/aggregatable.dart';
import 'package:firestore_odm/src/interfaces/deletable.dart';
import 'package:firestore_odm/src/interfaces/filterable.dart';
import 'package:firestore_odm/src/interfaces/gettable.dart';
import 'package:firestore_odm/src/interfaces/insertable.dart';
import 'package:firestore_odm/src/interfaces/limitable.dart';
import 'package:firestore_odm/src/interfaces/modifiable.dart';
import 'package:firestore_odm/src/interfaces/orderable.dart';
import 'package:firestore_odm/src/interfaces/patchable.dart';
import 'package:firestore_odm/src/interfaces/streamable.dart';
import 'package:firestore_odm/src/interfaces/updatable.dart';
import 'package:firestore_odm/src/interfaces/upsertable.dart';
import 'package:firestore_odm/src/services/update_operations_service.dart';

/// A wrapper around Firestore CollectionReference with type safety and caching
class FirestoreCollection<S extends FirestoreSchema, T>
    implements
        Gettable<List<T>>,
        Streamable<List<T>>,
        Insertable<T>,
        Updatable<T>,
        Upsertable<T>,
        Orderable<T>,
        Filterable<T>,
        Patchable<T>,
        Modifiable<T>,
        Aggregatable<S, T>,
        Limitable,
        Deletable {
  /// The underlying Firestore collection reference
  final firestore.CollectionReference<Map<String, dynamic>> query;

  /// Model converter for data transformation
  final FirestoreConverter<T, Map<String, dynamic>> converter;

  /// Document ID field name (detected from model analysis)
  final String documentIdField;

  /// Creates a new FirestoreCollection instance
  FirestoreCollection({
    required this.query,
    required this.converter,
    required this.documentIdField,
  });

  /// Gets a document reference with the specified ID
  /// Documents are cached to ensure consistency
  /// Usage: users('id')
  FirestoreDocument<S, T> call(String id) =>
      FirestoreDocument(query.doc(id), converter, documentIdField);

  /// Upsert a document using the id field as document ID
  Future<void> upsert(T value) =>
      CollectionHandler.upsert(query, value, converter.toFirestore, documentIdField);

  /// Insert a new document using the id field as document ID
  /// Use FirestoreODM.autoGeneratedId for server-generated unique IDs
  /// Fails if document already exists (when ID is specified)
  Future<void> insert(T value) =>
      CollectionHandler.insert(query, value, converter.toFirestore, documentIdField);

  /// Update an existing document using the id field as document ID
  /// Fails if document doesn't exist
  @override
  Future<void> update(T value) =>
      CollectionHandler.update(query, value, converter.toFirestore, documentIdField);

  @override
  Future<List<T>> get() =>
      CollectionHandler.get<T>(query, converter.fromFirestore, documentIdField);

  @override
  Stream<List<T>> get stream =>
      QueryHandler.stream(query, converter.fromFirestore, documentIdField);

  @override
  OrderedQuery<S, T, O> orderBy<O extends Record>(
    O Function(OrderByFieldSelector<T> selector) orderBuilder,
  ) {
    final config = QueryOrderbyHandler.buildOrderBy(
      orderBuilder,
      documentIdField,
    );
    final newQuery = QueryOrderbyHandler.applyOrderBy(query, config);
    return OrderedQuery(newQuery, converter, documentIdField, config);
  }

  @override
  Query<S, T> where(FilterBuilder<T> filterBuilder) {
    final filter = QueryFilterHandler.buildFilter(filterBuilder);
    final newQuery = QueryFilterHandler.applyFilter(query, filter);
    return Query<S, T>(newQuery, converter, documentIdField);
  }

  @override
  Query<S, T> limit(int limit) {
    final newQuery = QueryLimitHandler.applyLimit(query, limit);
    return Query<S, T>(newQuery, converter, documentIdField);
  }

  @override
  Query<S, T> limitToLast(int limit) {
    final newQuery = QueryLimitHandler.applyLimitToLast(query, limit);
    return Query<S, T>(newQuery, converter, documentIdField);
  }

  @override
  Future<void> patch(PatchBuilder<T> patchBuilder) =>
      QueryHandler.patch(query, documentIdField, converter, patchBuilder);

  @override
  AggregateQuery<S, T, R> aggregate<R extends Record>(
    R Function(RootAggregateFieldSelector<T> selector) builder,
  ) {
    final config = QueryAggregatableHandler.buildAggregate(builder);
    final newQuery = QueryAggregatableHandler.applyAggregate(
      query,
      config.operations,
    );
    return AggregateQuery(newQuery, converter, documentIdField, config);
  }

  @override
  AggregateCountQuery count() {
    final newQuery = QueryAggregatableHandler.applyCount(query);
    return AggregateCountQuery(newQuery);
  }

  /// Modify all documents in this collection using diff-based updates.
  ///
  /// This method performs a read operation followed by batch update operations.
  /// Performance is slightly worse than [patch] due to the additional read,
  /// but convenient when you need to read the current state before writing.
  ///
  /// **Important Notes:**
  /// - **Performance**: This method has an additional read operation, making it slower than [patch]
  /// - **Concurrency**: Firestore uses last-write-wins semantics. This read-modify-write
  ///   operation is NOT transactional and may be subject to race conditions
  /// - **Transactions**: For transactional updates, use transactions instead
  ///
  /// [atomic] - When true (default), automatically detects and uses atomic
  /// operations like FieldValue.increment() and FieldValue.arrayUnion() where possible.
  /// When false, performs simple field updates without atomic operations.
  ///
  /// **Example:**
  /// ```dart
  /// // Update all users with atomic operations (default)
  /// await db.users.modify((user) => user.copyWith(
  ///   lastUpdated: FirestoreODM.serverTimestamp,
  ///   version: user.version + 1, // Auto-detects -> FieldValue.increment(1)
  /// ));
  ///
  /// // Update without atomic operations
  /// await db.users.modify((user) => user.copyWith(
  ///   status: 'migrated',
  /// ), atomic: false);
  /// ```
  @override
  Future<void> modify(ModifierBuilder<T> modifier, {bool atomic = true}) =>
      QueryHandler.modify(query, documentIdField, converter, modifier, atomic: atomic);

  /// @deprecated Use [modify] with atomic parameter instead.
  /// This method will be removed in a future version.
  ///
  /// **Migration:**
  /// ```dart
  /// // Old way (deprecated)
  /// await collection.incrementalModify((data) => data.copyWith(...));
  ///
  /// // New way (recommended)
  /// await collection.modify((data) => data.copyWith(...)); // atomic: true by default
  /// await collection.modify((data) => data.copyWith(...), atomic: true);
  /// ```
  @Deprecated('Use modify(atomic: true) instead. This method will be removed in a future version.')
  @override
  Future<void> incrementalModify(ModifierBuilder<T> modifier) =>
      QueryHandler.incrementalModify(
        query,
        documentIdField,
        converter,
        modifier,
      );

  @override
  Future<void> delete() => QueryHandler.delete(query);
}
